{
	program: [
		{
			rule: ["stmt_sequence"],
			semantics: function(stack){
				return stack.shift()(stack);
			}
		}
	],
	stmt_sequence: [
		{
			rule: ["statement", "_stmt_sequence"],
			semantics: function(stack){
				var stmt = stack.shift();
				var out = stmt(stack);
				var stmtSeq = stack.shift();
				out += stmtSeq(stack);
				return out;
			}
		}
	],
	_stmt_sequence: [
		{
			rule: ["EOS", "statement", "_stmt_sequence"],
			semantics: function(stack){
				stack.shift();
				var stmt = stack.shift();
				var out = stmt(stack);
				var stmtSeq = stack.shift();
				out += stmtSeq(stack);
				return out;
			}
		},
		{
			rule: ["&"],
			semantics: function(stack){
				return "";
			}
		}
	],
	statement: [
		{
			rule: ["if_stmt"],
			semantics: function(stack){
				return stack.shift()(stack);
			}
		},
		{
			rule: ["repeat_stmt"],
			semantics: function(stack){
				return stack.shift()(stack) + ';';
			}
		},
		{
			rule: ["assign_stmt"],
			semantics: function(stack){
				return stack.shift()(stack) + ';';
			}
		},
		{
			rule: ["read_stmt"],
			semantics: function(stack){
				return stack.shift()(stack) + ';';
			}
		},
		{
			rule: ["write_stmt"],
			semantics: function(stack){
				return stack.shift()(stack) + ';';
			}
		}
	],
	if_stmt: [
		{
			rule: ["IF", "exp", "THEN", "stmt_sequence", "_if_stmt"],
			semantics: function(stack){
				stack.shift();
				var out = 'if';
				var exp = stack.shift();
				out += '(' + exp(stack) + ')';
				stack.shift();
				var stmtSeq = stack.shift();
				out += '{' + stmtSeq(stack) + '}';
				var ifStmt = stack.shift();
				out += ifStmt(stack);
				return out;
			}
		}
	],
	_if_stmt: [
		{
			rule: ["END"],
			semantics: function(stack){
				stack.shift();
				return "";
			}
		},
		{
			rule: ["ELSE", "stmt_sequence", "END"],
			semantics: function(stack){
				stack.shift();
				var out = 'else';
				var stmtSeq = stack.shift();
				out += '{' + stmtSeq(stack) + '}';
				stack.shift();
				return out;
			}
		}
	],
	repeat_stmt: [
		{
			rule: ["REPEAT", "stmt_sequence", "UNTIL", "exp"],
			semantics: function(stack){
				stack.shift();
				var out = 'do';
				var stmtSeq = stack.shift();
				out += '{' + stmtSeq(stack) + '}';
				stack.shift();
				out += 'while';
				var exp = stack.shift();
				out += '(!(' + exp(stack) + '))';
				return out;
			}
		}
	],
	assign_stmt: [
		{
			rule: ["$IDENTIFIER", "ASSIGN", "exp"],
			semantics: function(stack){
				var out = stack.shift() + '=';
				stack.shift();
				var exp = stack.shift();
				out += exp(stack);
				return out;
			}
		}
	],
	read_stmt: [
		{
			rule: ["READ", "$IDENTIFIER"],
			semantics: function(stack){
				stack.shift();
				return stack.shift() + '=jsIn()';
			}
		}
	],
	write_stmt: [
		{
			rule: ["WRITE", "exp"],
			semantics: function(stack){
				stack.shift();
				var out = 'jsOut';
				var exp = stack.shift();
				out += '(' + exp(stack) + ')';
				return out;
			}
		}
	],
	exp: [
		{
			rule: ["simple_exp", "_exp"],
			semantics: function(stack){
				var simpexp = stack.shift();
				var out = simpexp(stack);
				var exp = stack.shift();
				out += exp(stack);
				return out;
			}
		},
		{
			rule: ["QT", "string"],
			semantics: function(stack){
				var out = stack.shift();
				var string = stack.shift();
				out += string(stack);
				return out;
			}
		}
	],
	string: [
		{
			rule: ["$TEXT", "string"],
			semantics: function(stack){
				var out = stack.shift();
				var string = stack.shift();
				var temp = string(stack);
				if(temp != '\"')
					out += ' ';
				out += temp;
				return out;
			}
		},
		{
			rule: ["QT"],
			semantics: function(stack){
				return stack.shift();
			}
		}
	],
	_exp: [
		{
			rule: ["comparison_op", "simple_exp", "_exp"],
			semantics: function(stack){
				var compOp = stack.shift();
				var out = compOp(stack);
				var simpexp = stack.shift();
				out += simpexp(stack);
				var exp = stack.shift();
				out += exp(stack);
				return out;
			}
		},
		{
			rule: ["&"],
			semantics: function(stack){
				return "";
			}
		}
	],
	comparison_op: [
		{
			rule: ["GT"],
			semantics: function(stack){
				return stack.shift();
			}
		},
		{
			rule: ["LT"],
			semantics: function(stack){
				return stack.shift();
			}
		},
		{
			rule: ["EQ"],
			semantics: function(stack){
				stack.shift();
				return '==';
			}
		}
	],
	simple_exp: [
		{
			rule: ["term", "_simple_exp"],
			semantics: function(stack){
				var term = stack.shift();
				var out = term(stack);
				var simpexp = stack.shift();
				out += simpexp(stack);
				return out;
			}
		}
	],
	_simple_exp: [
		{
			rule: ["addop", "term", "_simple_exp"],
			semantics: function(stack){
				var addop = stack.shift();
				var out = addop(stack);
				var term = stack.shift();
				out += term(stack);
				var simpexp = stack.shift();
				out += simpexp(stack);
				return out;
			}
		},
		{
			rule: ["&"],
			semantics: function(stack){
				return "";
			}
		}
	],
	addop: [
		{
			rule: ["ADD"],
			semantics: function(stack){
				return stack.shift();
			}
		},
		{
			rule: ["SUB"],
			semantics: function(stack){
				return stack.shift();
			}
		}
	],
	term: [
		{
			rule: ["factor", "_term"],
			semantics: function(stack){
				var factor = stack.shift();
				var out = factor(stack);
				var term = stack.shift();
				out += term(stack);
				return out;
			}
		}
	],
	_term: [
		{
			rule: ["mulop", "factor", "_term"],
			semantics: function(stack) {
				var mulop = stack.shift();
				var out = mulop(stack);
				var factor = stack.shift();
				out += factor(stack);
				var term = stack.shift();
				out += term(stack);
				return out;
			}
		},
		{
			rule: ["&"],
			semantics: function(stack){
				return "";
			}
		}
	],
	mulop: [
		{
			rule: ["MUL"],
			semantics: function(stack){
				return stack.shift();
			}
		},
		{
			rule: ["DIV"],
			semantics: function(stack){
				return stack.shift();
			}
		}
	],
	factor:	[
		{
			rule: ["LP", "exp", "RP"],
			semantics: function(stack){
				var out = stack.shift();
				var exp = stack.shift();
				out += exp(stack);
				out += stack.shift();
				return out;
			}
		},
		{
			rule: ["$NUMBER"],
			semantics: function(stack){
				return stack.shift();
			}
		},
		{
			rule: ["$IDENTIFIER"],
			semantics: function(stack){
				return stack.shift();
			}
		}
	]
};
